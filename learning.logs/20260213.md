# 과제
1. DB를 생성하시오.
  - DB 명 : play_transaction
2. TABLE을 생성하시오.
  - TABLE 명 : products
    1. column 명 : product_name varchar(50) / primary key
    2. stock int / not null

  - table 명 : orders
    - column 명 :
      1. order_id / int / auto_increment / pk
      2. product_name varchar(50) / fk
      3. quantity int 

```sql
CREATE TABLE products (
	product_name VARCHAR(50) PRIMARY KEY,
	stock INT NOT null
);

CREATE TABLE orders (
	order_id INT AUTO_INCREMENT PRIMARY KEY,
	product_name VARCHAR(50),
	quantity INT,
	FOREIGN KEY (product_name) REFERENCES products(product_name)
);

INSERT INTO products
	VALUES('iPhone18ProMax', 10);

SELECT * FROM products;
```

# Transaction
## 정의
- 트랜잭션은 데이터베이스의 상태를 변화시키기 위해서 수행하는 _논리적인 작업 단위_ 를 의미함. 여러 개의 SQL문을 묶어서 모두 성공하거나, 아니면 아예 수행되지 않은 상태로 처리하는 것을 의미함.

- python 상에서 coffeeMachine을 할 때를 생각해보시면 특정 함수/메서드가 성공했을 때만 다음 단계로 넘어갔었고, 아니면 아예 실패하면서 profit의 변화나 resources에서 변화가 없었습니다.

- 즉 현재까지의 저희 수준을 기준으로 SQL문을 다수 작성해놓고 그것을 하나의 루틴으로 묶은 SQL문 수준의 함수 / 메서드와 유사하다고 보시면 되겠습니다.

## 트랜잭션의 특성
1. 원자성(Atomicity) : 트랜잭션 내 작업은 모두 반영되거나 모두 취소되어야 함.
2. 일관성(Consistency) : 트랜잭션 완료 후 DB는 항상 미리 정의된 제약 조건을 준수해야 함.
3. 격리성(Isolation) : 실행 중인 트랜잭션은 다른 트랜잭션의 간섭을 받지 않아야 함.
4. 지속성/영속성(Durability) : 트랜잭션 결과는 시스템 오류가 발생해도 영구적으로 저장됨.

## 트랜잭션 제어어(TCL : Teansaction Controll Language)
1. `START TRANSACTION` : 트랜잭션 시작을 선언
2. `COMMIT` : 모든 작업이 정상일 때, 변경 내용을 실제 DB에 영구 저장
3. `ROLLBACK` : 작업 오류 발생 시, `START TRANSACTION` 직전 상태로 복구

```sql
-- 성공사례
START TRANSACTION;
-- -- 주문 접수
INSERT INTO orders (product_name, quantity) VALUES ('iPhon18ProMax', 2);
-- -- 재고 차감
UPDATE products SET stock = stco - 2 WHERE product_name = 'iPhone18ProMax';
-- 
COMMIT;
-- 
SELECT * FROM products;
SELECT * FROM orders;
-- 
-- 어차피 성공했기 때문에 우리가 그냥 SQL문 죽 나열했을 때와 다를 바가 없다.

-- 실패 사례
START TRANSACTION;
-- products에 없는 걸 주문
INSERT INTO orders (product_name, quantity) VALUES ('GalaxyS26Ultra', 1);
-- 아예 테이블 명이 틀린 경우
INSERT INTO orders_miss(product_name, quantity) VALUES ('GalaxyS26Ultra', 1);
-- TABLE 'play-transaction.orders_miss' dosen't exist

UPDATE products SET stock = stock - 1 WHERE product_name = 'GalaxyS26Ultra';

ROLLBACK

SELECT * FROM products;
SELECT * FROM orders;
```

- 그런데 DB 상에서 문제가 여전히 존재하는 것처럼 보입니다. 재고가 음수값이면 어떡하지? 가 그 예시에 해당합니다.

```sql
START TRANSACTION;

SELECT * FROM products WHERE stock < 0;

COMMIT;
```

근데 이건 그냥 음수인거 확인되면 성공이란 뜻이고, 혹은

```sql
START TRANSACTION;

SELECT * FROM products WHERE stock < 0;

ROLLBACK;
```
음수라면 그냥 롤백시키겠다는 의미입니다.

그렇다면 orders관련한 부분의 트랜잭션 내부에서 다시 트랜잭션을 재정의 해야한다는 것을 의미합니다.

# Trigger
## 정의
- 테이블에 insert, update, delete와 같은 이벤트가 발생했을 때 데이터 베이스가 자동으로 실행하도록 설정된 SQL 블록입니다.
- 활용 사례
  - 주문 재고 시 자동 차감(데이터 연동)
  - 데이터 변경 시 로그 기록(감사 및 기록)
  - 특정 조건 미달 시 데이터 입력 차단(무결성 강화)

## 트랜잭션과의 차이점
- 둘 다 데이터의 무결성을 지키기 위한 것이라는 공통점을 가지지만, 작동하는 방식과 주체에서의 차이가 존재함.

### Transaction
- 핵심 성격 : 논리적 작업 단위(묶음 처리)
- 실행 주체 : 개발자(내가 직접 작성해야합니다)
- 작동 시점 : `START` / `COMMIT` 시점
- 주요 목적 : 데이터의 안전한 _일관 처리_
- 즉, 내가 SELECT 눌러보고 하나하나 체크해서 이게 명확한 테이블 명이고 컬럼 명인지 확신을 못하고 있는 상황에서 중간 과정에 값이 바뀌면 안되니까 보험 걸어놓고 묶어둔 SQL문을 실행시키겠다면 : TRANSACTION 적용

### Trigger
- 핵심 성격 : 이벤트 반응
- 실행 주체 : DBMS가 자동으로 실행
- 작동 시점 : `INSERT / UPDATE / DELETE` 발생 시
- 주요 목적 : 데이터 간의 _자동 연동 및 기록_
- DB에 미리 정의해놓고 누군가가 orders에 대고 데이터를 집어넣었네(외부에서 나에게 주문을 넣었다면)? -> DB가 감시하고 있다가 products 테이블에 재고 뺴는 거 실행함 -> 근데 음수값이야 -> '재고가 부족합니다' 를 띄워야겠네. 와 같은 부분을 정의된 대로 실행시킵니다.

## 정리를 하자면
**트리거는 트랜잭션의 일부**에 해당합니다. INSERT를 할 때 트리거가 발동돼서 재고를 깎는데 오류가 나면 INSERT를 포함한 전체 트랜잭션이 실패합니다. 즉, 트리거도 트랜잭션의 원자성을 따른다고 해석할 수 있습니다.

- 그래서 여기서 더 발전하면 Stored procedure 개념도 있기는한데 JPA에서도 안다룰거고 SQLD에 없다면 이런게 있다는 정도만 알고 지나가겠습니다.

