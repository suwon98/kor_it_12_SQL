## CROSS JOIN
- 예제 문제 : users와 orders의 _모든 가능한 행 조합_ 을 만들어내는 쿼리를 작성하시오.
```sql
SELECT * FROM users u CROSS JOIN orders o;
```
- CROSS JOIN은 두 집합을 조합해 만들 수 있는 모든 경우의 수를 생성하는 `카테시안 곱(cartesian product)`을 출력한다. u.id와 o.user_id를 연결하는 등의 조건이 없이 두 테이블의 모든 행을 합쳐서 만들 수 있는 모든 경우의 수를 만드는 것에 해당함.
- 예를 들어 10행인 테이블과 20행인 테이블을 CROSS JOIN하면 결과 테이블은 10*20인 200행이 됩니다. 그리고 이외의 경우의 수는 존재하지 않습니다.
- 모든 경우의 수를 만들어내기 때문에 ON조건을 설정할 필요가 없음.

## JOIN에 대한 전반적인 정리
- 두 테이블의 행을 서로 조합하는 과정인데, 여러가지(LEFT, RIGHT, INNER, CROSS, FULL OUTER)가 존재하면서, ON 조건을 활용하여 전체 경우의 수에서 어떤 행만 가져올 수 있을지를 정할 수 있다.
- FULL OUTER JOIN의 경우 CROSS JOIN과 차이가 존재하는데, LEFT JOIN의 결과값과 RIGHT JOIN의 결과 값을 _중복 없이_ 결합하는 개념으로, 합집합에 해당함. 전체를 구하는 컨셉은 유사하나 합집합이 전체 경우의 수를 의미하는 것은 아니기 때문에 구분해서 사용할 필요가 있습니다. CROSS JOIN과 달리 ON 조건을 요구합니다.

- 운영 환경에서는 CROSS JOIN을 제한하는 편입니다. 전체 경우의 수를 구하는데 실제로 필요한 경우는 거의 없기 때문입니다.

- FULL OUTER JOIN의 경우 DB에 따라 아예 지원하지 않는 경우도 있음.

### 연습문제
1. users와 staff를 참고하여 회원 중 직원인 사람의 회원 id, 이메일, 거주도시, 거주국가, 성, 이름을 출력하시오.

2. staff와 orders를 참고하여 직원 아이디가 3번, 5번인 직원의 담당 주문을 출력하시오. 단 직원id, 직원 성, 주문 아이디, 주문일자만 출력하시오.

3. users와 orders를 참고하여 회원 국가 별 주문 건수를 내림차순으로 출력

4. orders와 orderdetails, products를 참고하여 회원 아이디 별 주문 금액의 총합을 정상 가격과 할인 가격 기준으로 각각 구하시오. 단, 정상 가격 주문 금액의 총합 기준으로 내림차순 정렬할 것.

5. 이하의 조건에 해당하는 테이블이 있다고 가정했을 때 질문에 답하시오.
    - 왼쪽 테이블 A : 컬럼 개수 5개 / 150행
    - 오른쪽 테이블 B : 컬럼 개수 7개 / 100행
    - 두 테이블은 공통 키 값 컬럼을 1개 보유
  위 조건의 두테이블을 CROSS / LEFT / RIGHT / INNER JOIN으로 결합했을 때 결과 테이블의 행과 열 개수를 계산하시오(SELECT * 기준)
- CROSS JOIN
  - rows : 15000 행(150*100)
  - columns : 12개
- LEFT JOIN
  - rows : 최소 150, 최대 15000행
  - columns : 12개
- RIGHT JOIN
  - rows : 최소 100, 최대 15000행
  - coulmns : 12개
- INNER JOIN
  - rows : 최소 0행, 최대 15000행
  - columns : 12개

- 이상의 답안은 SQLD 중심이라기 보다 실무에서 일어날 수 있는 수준이고 실제 시험 상황에서는 구구단 수준 +@ 로 나올거기 때문에 실제 rows 계산 정도는 하게 될 수 있습니다.

## UNION
- 컬럼 목록이 같은 데이터를 위아래 결합
- 컬럼의 형식과 개수가 같은 두 데이터 결과 집합을 하나로 결합하는 기능.
- JOIN은 ON이 요구된다는 점이 있지만 애초에 제약 조건이 있는 UNION의 경우는 제약 조건을 일치시킨다면 결합 자체는 가능함.

- 예제 문제 : users를 full scan한 결과 집합에서 각 행을 2번씩 출력하기
```sql
(SELECT * FROM users) UNION ALL (SELECT * FROM users);
```
이상의 쿼리를 생각했을 때 앞에서 배운 이론적인 부분과 합쳤을 때 77 * 2 의 결과값이 나와야 할 것으로 보입니다. 하지만

좌측 상단을 확인했을 때 `결과`로 표시되는 것으로 보아 users를 그대로 가지고 온 것이 아니라는 것을 알 수 있습니다. 이는 중복제거가 적용된 결과값에 해당합니다.

  - 중복 제거를 하지 않는 방식으로 적용하는 방법 : `UNION ALL`
```sql
(
  SELECT * FROM users
  ) 
  UNION ALL 
  (
    
    SELECT * FROM users
  )
;
```
  - UNION 및 ALL을 적용했을 때 SELECT문을 쓸 때 full scan한다면 상관없지만 특정 컬럼만 보여주겠다고 한다면 첫 번째 테이블에서 컬럼을 편집한 것과 동일하게 두 번째 테이블도 수정해야 합니다.
```sql
(SELECT id, phone, country, city FROM users)
UNION ALL
(SELECT id, phone, country, city FROM users)
ORDER BY id;
```

그래서 지사에서 올라온 각 테이블의 row들을 통합할 때 본사에서 UNION을 쓸 수는 있겠네요.
실무적으로 UNION보다는 UNION ALL을 더 권장합니다. 대량의 데이터에서 중복 항목을 제거할 때 부하가 일어날 수 있기 때문에 일단 중복되더라도 보여주는 것을 좀 더 선호하고, 그 후에 조건절 등을 통해 분류합니다.

- 문제 : users에서 거주 국가가 Korea 회원 정보만 추출하고, Mexico인 회원 정보만 추출하여 _결합 하시오_ 단, 회원아이디, 연락처, 거주도시, 거주국가만 출력하고, 거주국가 기준 알파벳 오름차순으로 작성
```sql
(
SELECT id, phone, city, country
 FROM users 
 WHERE country = 'korea'
)
UNION ALL
(
SELECT id, phone, city, country
 FROM users
  WHERE country = 'Mexico'
)
ORDER BY country
;
```
### 연습문제
1. orders에서 주문일자가 2015년 10월인 건과 2015년 12월인 건을 SELECT로 각각 추출하고 UNION ALL을 사용해 하나로 결합하시오. 단, 최종 결과는 최신 순으로 정렬하시오.

2. users에서 미국에 거주 중이면서 마케팅 수신에 동의한 회원 정보와 프랑스에 거주 중이면서 마케팅 수신 동의 하지 않은 회원 정보를 SELECT로 각각 추출하고, 두 결과 집합을 UNION ALL을 사용해 하나로 결합하시오. 단, 최종 결과는 id, 연락처, 거주 국가, 거주 도시, 마케팅 수신 동의 여부 컬럼만 추출하고, 거주 국가 기준 알파벳 순 정렬하시오. 컬럼명 한국어로 다 바꾸시오.

3. UNION을 활용하여 주문 상세 정보 테이블 orderdetails와 제품 정보 테이블 products를 FULL OUTER JOIN 조건으로 결합하여 출력하시오.

## 서브쿼리(Sub Query)

- JOIN / UNION은 각각 좌우 / 상하로 두 테이블을 결합하는 방법이었습니다. 즉 이미 존재하는 테이블에 접근하여 결합을 시도 했다는건데, 내가 작성한 쿼리를 실행하여 나온 결과값인 테이블을 다시 사용하거나 조건으로 쓰거나, 혹은 값으로 쓸 수 있을까 와 관련된 부분이 서브쿼리입니다.

```sql
SELECT COUNT(DISTINCT id) FROM users GROUP BY country;

SELECT SUM(price * quantity) FROM products;
```
- SQL에서는 직접 작성한 쿼리에서 나온 결과값을 마치 테이블처럼 사용할 수 있는 기능이 있는데, 이를 서브 쿼리라고 하며, 일반 SELECT문보다 먼저 연산이 되어야만 하기 때문에 `소괄호()`로 묶어서 SQL문을 작성합니다.(아까 UNION할 때 잠깐 써봤습니다). 해당 경우 실제 테이블은 아니지만 결과값을 테이블처럼 사용할 수 있습니다.

- 그런데 시험에 나올 때 sub query의 종류도 물어봅니다. 이는 서브쿼리가 어느 위치에서 사용되어지느냐에 따라서 결정지어집니다.

- 예시 문제 : products 테이블에서 제품명과 정상 가격을 모두 불러오고, 평균 정상 가격을 새로운 컬럼으로 각 행마다 출력하시오.
```sql
SELECT name, price, (SELECT ROUND(AVG(price), 2) FROM products) AS 평균가격 FROM products;
```

products의 name, 및 price의 각 row들을 불러오고, 마지막 컬럼의 모든 행에 평균 정상가격(컬럼명 평균가격)을 출력했습니다. 여기서 중요한 점은 `SELECT 절에는 단일 값을 반환하는 서브쿼리가 올 수 있음.` -> `스칼라 서브 쿼리(Scalar Sub Query)`

즉 어차피 서브 쿼리 내의 결과값이 38.8이므로
```sql
SELECT name, price, 38.8 AS 평균가격
	FROM products
	;
```
과 동일한 결과값이 나온다는 것을 알 수 있습니다. 그러면 계산해놓고 그대로 값 넣으면 되겠네요라고 생각할 수도 있을 것 같은데 어차피 중요한건 서브쿼리의 결과값이 단일값인 경우에 SELECT절에 들어갈 수 있다는 개념입니다.

그렇다면 평균 가격을 구하는 집계함수 자체는 우리가 알고 있으니까
```sql
SELECT name, price, AVG(price) AS 평균가격
  FROM products;
```
가 가능하지 않을까. ->
평균가격이 출력되기는 하지만 나머지 row들이 다 날아갑니다. 그 이유는 AVG(price)의 결과가 하나의 row에 해당되기 때문입니다.

- 이상의 과정에서 스칼라 서브쿼리를 작성할 때 _단일값_ 이 반환되도록 작성해야 한다는 점에서 유의해야 합니다. 만약에 2 개 이상의 집계값을 기존 테이블의 컬럼으로 추가하고, 각 행마다 붙이고 싶다면 서브 쿼리를 두 개로 나누어서 작성해야 합니다.

- 예시 문제 : users에서 city별 회원 수를 카운트하고 회원 수가 3명 이상인 도시명과 회원수를 출력하시오.(회원 수를 기준으로 내림차순 정렬하시오)
```sql
-- HAVING 사용 버전
SELECT city AS 도시명, COUNT(DISTINCT id) AS 회원수
	FROM users
	GROUP BY city
	HAVING COUNT(DISTINCT id) > 2
	ORDER BY 회원수 DESC
	;

-- 서브쿼리 사용 버전
SELECT *
  FROM (
    SELECT city, COUNT(DISTINCT id) AS 도시별회원수
    FROM users
    GROUP BY city
  ) a
  WHERE 도시별회원수 >= 3
  ORDER BY 도시별회원수 DESC
  ;
```
- 참조 사항 : subquery를 from 절에 집어넣었을 때 서브쿼리의 연산 결과값이 테이블로 사용된다는 것을 확인했습니다. 해당 경우 a를 명시하지 않으면 오류가 발생했습니다. 이는 약칭에 해당합니다(JOIN에서 썼습니다.) 서브쿼리의 결과값을 마치 변수에 대입하는 것으로 간주하시면 되겠습니다. 명시 안하면 연산 결과가 변수에 저장이 되지 않기 때문에 걔를 기준으로 main query의 연산을 불러올 수 없습니다.

- `FROM 절에서 사용된 서브 쿼리` -> `인라인 뷰(inline view)` : 인라인 뷰 안에서는 또 다른 서브쿼리가 중첩적으로 돌아갈 수 있습니다.

- 그러면 예상할 수 있는 골치 아픈 쿼리문으로 FROM절에 두 개의 서브 쿼리 집어넣은 다음에 그 두 개를 JOIN할 수도 있겠네요.

- 예시 문제 : orders와 staff를 활용해 성이 Kyle이거나 Scott인 직원의 담당 주문을 출력하시오.
```sql
SELECT *
	FROM orders
	WHERE staff_id IN (
		SELECT id FROM staff WHERE last_name IN ('Kyle', 'Scott'))
;
```
- Kyle의 직원아이디는 3이고, Scott은 5인 상황에서 orders에는 staff_id만 존재하기 때문에 last_name을 출력하기 위해서 where절 내에서 in 연산자 다음에 오는 부분에 서브쿼리를 적용하였습니다. 그래서 서브 쿼리 내에서는 staff 테이블의 id를 추출했고, 그것이 orders테이블에서는 staff_id와 일치하는지를 확인하는 과정을 통해서 결과값을 추출했습니다.

- 참조 사항 : WHERE에서 IN 연산자와 함께 서브 쿼리를 활용할 경우 서브쿼리에서 출력할 컬럼 개수와 필터링 적용 대상 컬럼의 개수가 일치해야 합니다. 저희는 staff_id라는 컬럼 하나만 있었기 때문에, 서브쿼리 내에서 staff테이블의 id 컬럼의 값들만 출력하도록 개수를 일치시켰습니다.

```sql
SELECT *
	FROM orders
	WHERE (staff_id, user_id) IN (
		SELECT id, user_id FROM staff WHERE last_name IN ('Kyle', 'Scott'))
;
```
- 즉 이상과 같이 staff_id와 user_id를 콤마로 구분하여 소괄호로 감싸주면 다중컬럼조건 필터링을 서브쿼리로 작성할 수 있습니다. 그리고 IN 내의 서브쿼리에서는 두 개의 컬럼에 값이 나와야겠네요.

- 결과값으로는 staff 테이블에 존재하는 id, user_id와 동일한 값이 staff_id, user_id 컬럼에 있는 경우만 반환하여 출력합니다. 즉, 직원 자신이 자사 쇼핑몰에서 주문한 이력을 출력한 예시라고 할 수 있겠습니다.

- 문제 : products에서 할인 가격이 가장 비싼 제품 정보를 출력하시오.

```sql
SELECT *
	FROM products
	WHERE discount_price IN (SELECT MAX(discount_price) FROM products)
	;

SELECT *
	FROM products
	WHERE discount_price = (SELECT MAX(discount_price) FROM products)
	;
```

- 문제 : orders에서 주문 월이 2015년 7월인 주문 정보를, 주문 상세 정보 테이블 orderdetails에서 개별 주문 수량이 50 이상인 정보를 각각 서브 쿼리로 작성하고, INNER JOIN하여 출력하시오.
```sql
SELECT *
	FROM (SELECT * FROM orders WHERE order_date >= '2015-07-01' AND order_date < '2015-08-01')o
	INNER JOIN
	(SELECT * FROM orderdetails WHERE quantity > 49) od
	ON o.id = od.order_id
	;

SELECT *
	FROM orders o INNER JOIN orderdetails od ON o.id = od.order_id
	WHERE SUBSTR(o.order_date, 1, 7) = '2015-07' AND od.quantity > 49
	;
```
1. 문제대로 풀었을 때 입니다.
2. 먼저 INNER JOIN을 수행했을 경우 orders의 컬럼과 orderdetails의 컬럼이 모두 포함될 겁니다. 그리고 특정 컬럼 값에 조건을 AND 연산자로 다 연결했습니다.

- 1, 2의 차이점은 INNER JOIN의 연산 시점이라고 할 수 있겠습니다. 미리 걸러내고 JOIN했는가, 혹은 다 합친 다음에 걸러냈는가라고 보셔도 무방합니다.

- 개별 테이블을 조인한 2 번 방법의 경우에는 테이블 두 개가 합쳐진 개수만큼 이미 데이터셋이 늘어나있는 상태에서 조건을 판별하기 때문에 결과값은 같지만 연산 속도상 느릴 것이라 추측할 수 있습니다.

### 연습 문제
1. products를 풀스캔하고 할인 가격의 최대값 대비 해당 제품의 할인 가격의 비율을 구해 ratioPerMaxPrc 컬럼명으로 추가하시오(단, 추가 컬럼이 소수점 셋째자리까지만 표기될 수 있도록 작성하시오).
```sql
SELECT *
	, ROUND(discount_price / (SELECT MAX(discount_price) FROM products), 3) AS ratioPerMaxPrc
	FROM products
;
```
2. users와 staff를 활용해 거주 국가가 한국이나 이탈리아이면서 생년월일이 1990-01-01 이전인 회원이자 직원인 사람의 정보를 서브 쿼리와 JOIN을 활용해 출력하시오(단 회원 아이디, 연락처 거주국가, 직원아이디, 성, 이름 컬럼만 출력할 것)
```sql
SELECT u.id AS 회원아이디
	, u.phone AS 연락처
	, u.country AS 거주국가
	, s.id AS 직원아이디
	, s.last_name AS 성
	, s.first_name AS 이름
	FROM (SELECT * FROM users WHERE country IN ('Korea', 'Italy')) u
	INNER JOIN
	(SELECT * FROM staff WHERE birth_date < '1990-01-01') s
	ON u.id = s.user_id
	;
```
3. users를 활용해 국가별 회원 수를 카운트하고 회원 수가 5 명 이상인 국가만 출력하시오(단 회원 수 기준 내림 차순 정렬)
```sql
SELECT * 
	FROM(SELECT country AS 국가, COUNT(DISTINCT id) AS 국가별회원수 FROM users GROUP BY country) u
	WHERE 국가별회원수 > 4
	ORDER BY 국가별회원수 DESC
;
```
4. products에서 정상 가격이 가장 저렴한 제품의 정보를 모두 출력하시오.
```sql
SELECT *
	FROM products
	WHERE price IN (SELECT MIN(price) FROM products)
	;
```
5. orders와 users를 활용해 2016년도에 주문 이력이 있는(order_date활용) 회원의 정보를 모두 출력하시오.
```sql
SELECT *
	FROM users
	WHERE id IN (SELECT user_id FROM orders WHERE order_date BETWEEN '2016-01-01' AND '2016-12-31')
	;
```
## DDL 및 CUD 연습용 DB 생성 쿼리문
```sql
CREATE DATABASE `ddl_crud_practice` /*!40100 COLLATE 'utf8mb4_uca1400_ai_ci' */
```

# SQL 온라인 코딩 테스트
1. https://hackerrank.com : 해커랭크(카카오에서 얘를 코테 플랫폼으로 활용하는 것으로 알려짐 - 문제 영어임)
2. https://leetcode.com : 리트코드, 해외 기반, 실제 기업 입사 시험과 유사한 구성이 있어서 도움이 꽤 됨. 알고리즘도 있음.
3. 프로그래머스
4. w3schools
